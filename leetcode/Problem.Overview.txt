3Sum
    要找a + b + c = 0
    首先一个for loop枚举a，里面一个Left下标 一个Right下标分别从两头开始扫描，根据当前Sum与0的关系决定移动Left 和Right
    处理duplicate，扫描找到一组解的时候就可以把Left Right 跳过相同数值的一段
    时间复杂度：O(N^2)
3Sum Closest
    类比3Sum做法，在移动Left Right 时记录最优解，也有可能正好有直接等于target的情况，
    时间复杂度：O(N^2)
4Sum
    类比3Sum做法，枚举2个，然后再扫描。
    O(N^3)
Add Binary
    2个二进制字符串加法，模拟之即可，注意字符串坐标
    时间复杂度：O(L) L就是两个字符串长的那个
Add Tow Numbers
    2个十进制数，用单链表存起来，两者相加，模拟之即可
    时间复杂度：O(L) L两个链表长的那个
Anagrams
    题目大意，给你一些字符串，找出其中组成字符串的字母相同的字符串，比如bbac 和 bacb就互为Anagrams
    把所有字符串按照特殊的方式排序，这样互为Anagrams的字符串就会排在一起，
    这个排序种比较的方式，是把每个字符串本身按照从a-z的方式排序好，然后以这个字符串大小来排序
    时间复杂度：O(N * LlogL + N) L是字串的长度，N是字符串个数，首先把每个字符串本身按照a-z的顺序重组好是 N * L log L，然后再扫描一遍
Balanced Binary Tree
    平衡树的定义是对于以任何一个节点为根的子树，它的左子树和右子树之差<=1
    根据它的定义，就可以用递归的方法来判断。递归的过程中可以获得左右子树的高度，然后递归回到当前层的时候，就可以判断了。
Best Time to Buy and Sell Stock
    只能最多买卖一次，要求最大利润，贪心的想，肯定是找相差最大的price[i] price[j] (i < j && price[i] < price[j])
    从后往前扫描，维护maxPrice，表示i+1-N天中间的最大利润，然后看price[i]与maxPrice是不是构成更优解，然后用price[i]更新maxPrice，i--
Best Time to Buy and Sell Stock II
    你可以买无数次，要profit最大。那就是在一个递增的序列中，最头买，最后卖。
    扫描整个数组，
    如果price[i] < price[i - 1] 这个时候买进
    如果price[i] > price[i - 1] && price[i + 1] < price[i] 那么就在这个时候卖出
Best Time to Buy and Sell Stock III
    最多可以买2次，可以根据Best Time to Buy and Sell Stock题的方法,可以求出每一天买进的max profit，然后可以由此得到从第i天往后看right[i]，买卖一次获得的最大利润。
    然后我们再次从前往后扫描，扫到i时可以获得以i为卖出，可以获得的max profit，然后加上right[i+1]就是最多2次的最大利润
Binary Tree Inorder Traversal
    二叉树的中序遍历，递归和非递归形式。非递归的形式，就是手动模拟那个递归时的压栈，出栈。
Binary Tree Level Order Traversal
    把一个二叉树保存成一个二维vector，每一个vector保存一层，从上到下，从左到右，
    宽搜即可，边宽搜就可以保存了
Binary Tree Level Order Traversal II
    把一个二叉树保存成一个二维vector，每一个vector保存一层，从下到上，从左到右
    宽搜，记录好每一层的分界点，最后再扫描保存
Binary Tree Maximum Path Sum
    递归求解，对于每一个节点，可以先求出以它自己为路径的一端，往它的子孙走的最大值Path Sum。
    那么对于一个节点它可能构成的路径有3种：
    1. 它与它的左孩子构成的路径连一起
    2. 它与它的右孩子构成的路径连一起
    3. 它与它的左右孩子构成的路径全部连在一起，
    这3种都有可能构成一个组更优的解。
Binary Tree Zigzag Level Order Traversal
    把一个二叉树保存成一个二维vector，每一个vector保存一层，从上到下，之字形保存，第一行从左到右，第二行从右到左，以此类推。
    宽搜，记录这一层的界限，然后按照相应的顺序保存。

    
Climibing Stairs
    F[i] = F[i - 1] + F[i - 2] 最终答案是 F[N]  边界情况是 F[1] = 1  F[2] = 2 
    我记得你说 F[0] = 1不科学，所以你可以从i=3开始再开始循环
Combination Sum
    递归产生答案，每一层的时候维护一个sum值，表示现在的和如果已经大于target，就可以不往下递归了。
    避免重复的问题，一开始把元素都排序，递归每一层的时候，每次都会找与之前不同的元素往下递归。
    每个元素可以用多次。
Combination Sum II
    做法与上一题类似，只是注意这题每个元素只能用一次。
Combinations
    给你N K，求元素1..N 选K个不同的所有排列。递归即可。
Construct Binary Tree from Inorder and Postorder Traversal
    后序的最后一个元素就是根，找到它在中序里的位置，然后分成左右两遍，然后递归下去。
Construct Binary Tree from Preorder and Inorder Traversal
    前序的第一个元素就是根，找到它在中序里的位置，然后分成左右两遍，然后递归下去。
Container With Most Water
    左右2个下标Left Right 如果当height[Left] < height[Right] 的时候就一直Left++
    反之 则一直Right-- 直到Left >= Right 这个移动的过程中，更新最优答案
Convert Sorted Array to Binary Search Tree
    把中间一个元素作为root，然后左边的就是左子树，右边的就是右子树，然后递归构造之。
Convert Sorted List to Binary Search Tree
    同上一题的做法，只是LinkList相对比较麻烦一点
Count and Say
    构造这个字符串，然后输出str[n]
    
Decode Ways
    F[i] = F[i - 1] 如果 第i个字符本身可以decode
	  + F[i - 2] 如果 第i-1 i 2个字符拼起来可以decode
    最后答案就是F[len]
Distinct Sebsequences
    F[i][j] 表示T串的0-i字符 由S串的0-j个字符能match多少种不同的方案
    F[i][j] = F[i][j - 1] 
	  + F[i - 1][j - 1] (如果T[i] == S[j])
    最后答案F[lenT][lenS]
Divide Tow Integers
    把答案转成2进制看，然后用逼近的思想，开始找到除数是被除数的 2^k 倍数 然后减去，ans += 2^k，之后k-- 再尝试，如果可以减去, 再相应的ans 累加，知道k = 0尝试完
Edit Distance
    F[i][j] 表示word1的0..i个字符 match word2[0..j]的字符最少步数
    F[i][j] = min{
		    F[i - 1][j - 1] (如果 word1[i] == words[j])
		    F[i - 1][j] + 1,  （相当于删除word2[j])
		    F[i][j - 1] + 1   (相当于删除word1[i])
		 }
First Missing Positive
    O(N)的做法，从头到尾扫描A[i]，然后调整使得A[i]一定存着i + 1 如果这样的i + 1存在的话，
    具体的做法就是 如果A[i] 不是i + 1 
    那么如果A[i] <= 0 or A[i] > N 就没事了，不然的话就把A[A[i] - 1] 与 A[i] 交换
    然后直到不能交换
Flatten Binary Tree to Linked List
    如果要in place, 我的做法是递归，先把每个节点的左右子树弄好，返回的时候返回折腾好的这个链条的最后一个节点
    然后左右子树递归回来到自己这一层的时候，跟觉左右子树的情况链接起来
Generate Parentheses
    递归的构造所有的括号串，对于当前的括号串，后面可以+） 也可以+( 
    如果+( 需要判断 是不是还有(可以加
    如果+）不仅需要判断 是不是还有)可以加还需要判断现在括号串里 ）个数是不是小于(
Gray Code
    这个题目有2种做法，一种就是直接生成，很数学，gray[i] = i ^ (i >> 1)  i = [0..2^N - 1]
    另一个就是构造，首先N = 1 的时候就是 0 1 2个
    对于N > 1 的时候就是按照grey[N - 1][i] (i=0 ~ 2^(N-1) - 1) 前面+0 然后按照反过来 前面+1 (i=2^(N-1) - 1 ~ 0)
        
Implement strStr()
    直接2重循环比较好了。
Insert Interval
    这题是你教我做的，给你的区间们已经是排序好的，从头到尾扫描，找到某个区间，newInterval.right是小于该区间左端点的，那就就是插入在它前面的，
    否则然后看右端点，如果newInterval.left > 右端点 那么肯定不是插到它之前，
    如果他们有重叠，就更新newInterval，然后继续往后看。
Integer to Roman
    4 和 9 是要用到减法的，其他的就是用加法，直接模拟
Interleaving String
    F[i][j] 表示 s1 的0..i字符 和 s2的0..j字符是不是match s3的0..i+j+1字符
    F[i][j] = F[i][j - 1] && s2[j] == s3[i + j + 1] || F[i - 1][j] && s1[i] == s3[i + j + 1]
Jump Game
    一开始只能在0位置，然后看0位置能走多远，假设能走到far，那么0..far之内的位置都可以到，然后就看这中间能不能有到更远的far位置，
    直到扫到某个位置i 已经大于far 那么i就是不可到了i之后的都不可到了。
    所以只要求出far看far一旦>=N-1就可以到target了
Jump Game II
    用上题的思路，一轮一轮的求far，每一轮就从当前i走到lastFar,这次能走到的最远位置far就是这一轮能走到的最远位置，最优答案就轮数。
Largest Rectangle in Histogram
    用栈，栈的每个元素是一个pair(高度值，这个高度可以走到的最左坐标)，
    从前往后扫描每一个height，如果当前height大于堆顶那么就压栈，把这个高度以及它能达到的最左坐标，
    如果小于等于，就出栈，出栈时可以算出以出栈的这个元素高度的构成的最优面积。
    要记得保留下它的最左坐标，因为最后这个新的高度压栈时，要连着这个坐标压栈
    时间复杂度O(N)
Length of Last Word
    从后往前找到第一个非空格的字符，然后从这个位置从后往前，找到第一个空格位置，这中间的就是最后一个字符串长度
Letter Combinations of a Phone Number
    递归，每一层枚举当前这层的这个数字可能对应的字符，
Longest Common Prefix
    先把前两个字符串比较得到一个substring，然后把这个substring与第三个比较，以此类推。
Longest Palindromic Substring
    这个leetcode上有一篇文章，首先是把字符串前后以及每个字符之间插入一个#，比如'abc'变成'#a#b#c#'
    然后新串中针对每个位置可以求出一个l[i]表示的就是以i字符为中心，最长的回文串长度。这个可以用O(len)的方法求出。
    主要是新串中l[i]是具有对称性的。具体可以看leetcode里的那篇文章。
Longest Substring Without Repeating Characters
    一个l下标，一个r下标，一开是都在0位置，然后r一直往后走，没走过一个字符就mark这个字符，直到走到当前位置，发现这个字符之前已经mark过，那么l~(r-1)就是一段没有repeat的字符串。
    然后l往前走，同时把走过的字符unmark，直到走过一个字符这个字符等于r之前发现已经mark过的字符，因为这里l走过之后它就unmark了。
    直到r走过最后一个字符。这个整个过程里，就可以找到最优解。
Longest Valid Parentheses
    从前往后扫描，碰到(就p++碰到)就p-- 如果p变成负数就p=0重来如果p 等于0 那么前一段就可以构成一组解。
    然后类似的从后往前再做一遍，一定要从后往前做，不然会miss一些情况，比如(()

Maximal Rectangle
    01二维矩阵中找最大的全是1的矩形，枚举i，计算以第i行为底所能构成的最大矩阵，这个可以转化成Largest Rectangle in Histogram 问题。
    时间复杂度O(N^2)
Maximum Depth of Binary Tree
    二叉树的最大深度，递归求解，当前节点的最大深度是max(左子树最大深度，右子树最大深度)+1
Maximum Subarray
    从前往后扫描数组，sum累加，如果sum加上当前的A[i]小于0了就清零从这个位置之后开始累加
    整个过程里用sum更新最优答案
Median of Two Sorted Arrays
    这个题目有文章，但是我的做法就是用的那个logN + logM的找Kth number的方法
Merge Intervals
    首先把区间按照左端点排序，然后从前往后扫描，用之前Insert Interval的判断方法，相当于一开是interval的列表是空的，
    然后一个个插入这些区间
Merge k Sorted Lists
    每次检查这K个List找到最小的那个元素所在的List，然后把它取出来加到合并的List末尾，对应这个List也把它删掉
    直到所有List的元素都合并到新list里，
Merge Sorted Array
    从A B两个数组的后面往前扫描，然后放到对应A的下标上，知道B的元素都扫描完，合并就算结束了，不用管A是否扫描完
Merge Two Sorted Lists
    与Merge k Sorted Lists 大同小异
Minimum Depth of Binary Tree
    二叉树的最大深度，递归求解，当前节点的最小深度是min(左子树最小深度，右子树最小深度)+1
    但是注意的是，如果这个节点是只有左子树的，或者只有右子树的，就直接是这个子树的最小深度+1
    这里需要和max depth区分开
Minimum Path Sum
    F[i][j] 表示从左上角走到(i,j)的最小和
    F[i][j] = min (F[i - 1][j] , F[i][j - 1]) + grid[i][j]
Minimum Window Substring
    先统计T里每个字符出现的次数，然后S有两个下标L,R 一开是都在0位置 然后R往后移动，
    移动的时候同时统计S中L~R区间各个字符出现次数，然后check是不是全部都大于等于T的每个字符出现次数了。
    然后R不动，L再尝试往前移动，相应的字符出现次数需要减去，直到移动到，不能再向前，因为如果再减去，
    就不是T的每个字符在S的L～R都出现了大于等于那么多次。这样就可以得到一组解。
    然后反复的移动R，再移动L，知道R移动到最后。
    过程中可以得到最优解。
Multiply Strings
    高精度乘法，模拟手算。
N-Queens
    递归求解，每次枚举这一行放在哪一列，有3个mark数组，分别用来mark列，对角线，和反对角线。
    递归下去的时候标记true，递归回来的时候标记回false
N-Queens II
    我认为与上题没什么区别，一个是需要方案，一个只要个数。

Next Permutation
    从后往前找到第一个A[i] < A[i + 1]，然后把它往后交换，首先交换到A[i+1] 这个时候如果它还小于A[i+2] 然后又与A[i+2]交换，
    直到不小于它的右边这个元素，然后把它右边的所有元素，假设为A[k] .. A[N - 1] 调换顺序，就是变成A[N-1] A[N-2] .. A[k+1] A[k]
Palindrome Numbers
    先把Number的符号取出来，然后当作非负做，每次%10，取出末位，然后ans = ans * 10 + 末位，然后原数/10 直到原数变成0
    然后判断是不是和原数字相等
Partition List
    新建2个链表，一个用来存小于等于x的，一个用来存大于x的，从头到尾扫描原链表，然后根据情况往新的2个链表尾部链接，
    最后把新链表连接起来即可
Pascal's Triangle
    求杨辉三角，假设下标都是1开始，第i行有i个元素，Tri[i][j] = 1 (i == j || j == 1)  
    或者 Tri[i][j] = Tri[i - 1][j - 1] + Tri[i - 1][j]
Pascal's Triangle II
    基于上题的基础，对于每一行从后往前计算Tri[j] 这个时候Tri[j] 以及之后的就是第i行的，
    j之前的1 ~ j-1 就是第i-1行的，这样就做到只用O(N)的空间了
Permutation Sequence
    从最左边开始，依次考虑这一位是什么，如果能减去剩下位数的阶乘，那这一位就不能填这个数字，然后依次往后计算
Permutations
    与求1..N的全排列没有太多区别
Permutations II
    在上题的基础上，可能出现重复数字，也就是递归每一层的时候记得不能和之前递归下去过的元素相同
Plus One
    模拟即可
Populating Next Right Pointers in Each Node
    因为是一棵完全二叉树，所以递归计算，如果当前节点是父亲节点的左孩子，那么它的next一定是父亲节点的right，
    如果是右孩子，那么看它的父亲节点是否有next 如果有就是next的左孩子，否则它就没有next了
Populating Next Right Pointers in Each Node II
    一个普通的二叉树，可以沿用上面的方法，
    对于是父亲的左孩子，先看是不是父亲有右孩子，那么next就是这个右孩子
    否则无论是父亲的左孩子还是又孩子，扫描当前节点的父亲节点的next，如果next有左孩子那么它就是next，如果有右孩子就是这个右孩子，
    不然就继续往这个节点的next看，直到没有next
Pow(x, n)
    logN的时间复杂度求 x的n次方，
Recover Binary Search Tree
    根据这个树的中序遍历，找到第一个小于前面一个元素的元素，以及最后一个， 他们俩交换就ok了。
Regular Expression Matching
    F[i][j]表示S的前i个字符和P的前j个字符是否match，这里只有p是正则表达式
    F[i][j] = F[i - 1][j - 1] && (S[i] == P[j] || P[j] == '.')
	      || F[i][j - 2] && P[j] == '*'  // *可以表示把前面这个字符重复0次
	      || F[i - 1][j] && (P[j] == '*' && (S[i] == P[j - 1] || P[j - 1] == '.'))
Remove Duplicates from Sorted Arrays		
    从前往后扫描数组，相当于有两个坐标，i, now, now表示现在存到的坐标，i表示扫描到的坐标，如果A[i] 不等于 A[now] 就now++ A[now] = A[i]
Remove Duplicates from Sorted Arrays II
    与上题类似，只是判断时只有不等于A[now] && A[now - 1] 才不它加入进来
Remove Duplicates from Sorted List
    与Array的做法相同，只是这里是链表的处理
Remove Duplicates from Sorted List II
    与Array的做法相同，只是这里是链表的处理
Remove Element
    一个left，一个right下标，一开始left = 0 right = N - 1
    如果A[left] != x 那么left++ 否则swap(A[left], A[right]) right--
    如果swap完A[left]还是等于x则继续swap 并且right--
    直到left == right 那么 0 .. left - 1 就是所有剔除x的元素
Remove Nth Node From End of List
    用之前List种找中间那个元素的思路，第一个指针往前走N步，然后第二个指针从头开始再跟第一个指针一起往前走，直到第一个指针走到尾巴，
    那么第二个指针只到的位置就是.
    也可以直接扫一遍知道总元素个数，再扫一遍，找到倒数第N个
Restore IP Addresses
    递归求解，递归到下一层有2种决策：
    1. 新起一个ip段，2. 连在上一层数字之后，不论那种都要相应的符合ip数字的规则
Reverse Integer
    跟之前那个判断回文数字类似。
    先把Number的符号取出来，然后当作非负做，每次%10，取出末位，然后ans = ans * 10 + 末位，然后原数/10 直到原数变成0
    注意负数的问题，就是INT_MIN = -2^31 但是INT_MAX = 2^31 - 1
Reverse Linked List II
    翻转n～m这一段的链表，对于一般的整个链表反转关键就是下面4句话
    next = now->next;
    now->next = pre;
    pre = now;
    now = next;
Reverse Nodes in k-Group
    上一题的加强版
Roman to Integer
    Roman数字中一般都是累加，只有可能有一种需要减去的情况，就是 后一个字符表示的数字是大于前一个字符的。
Rotate Image
    每次选4个位置交换，我的做法似乎和你的不一样，你可以把你的方法自己补上。o(∩∩)o...哈哈
Rotate List
    首先得到这个链表的元素总数N，然后k = k % N 就是没有必要转那么多次。然后找到第k个，把原链表的尾巴连接到head，然后把k-1的next赋值为空
    
Same Tree
    递归判断，同时往左右子树走，如果发现不一样了就return false
Scramble String
    F[l][i][j] 从s1的i开始 s2的j开始 长度为l的2个串是否可以match，
    F[l][i][j] = F[k][i][j] && F[l - k][i + k][j + k] || F[k][i][j + l - k] && F[l - k][i + k][j]
    最后答案就是F[len][0][0] 
Search a 2D Matrix
    2种做法，1. 二分，logN + logM 先二分它在哪行，然后二分它在这行的哪个位置
    2. 把它当作每行递增每列也递增的矩阵，用那个O(N+M)的方法
Search for a Range
    二分找到x的右边界，就是最后一个x的位置，或者是第一个大于x的位置
    然后二分找到x-1的又边界，
    可以用这样子的二分方式,求这个右边界
    while (l < r)
    {
      int mid = (l + r) / 2;
      if (A[mid] < target) l = mid + 1;
      else r = mid;
    }
Search in Rotated Sorted Arrays
    这个题目，一定要列表里没有重复的元素，否则不能做到O(log N)，只能O(N)从头到尾扫描一次
    有两种做法，一种是先2分找到分界点k，然后再正常的二分, l = k, r = k + N - 1， 真正取下标的时候就是 mid % N
    另一种做法就是直接在上面二分，l = 0, r = N - 1
    但是判断mid 之后移动l r时需要考虑多种情况，
    当A[mid] >= A[l]时
      如果target >= A[l] && target <= A[mid] 那么 r = mid - 1 否则 l = mid + 1
    当A[mid] < A[l]时
      如果target >= A[mid] && target <= A[r] 那么 l = mid + 1 否则 r = mid - 1
Search in Rotated Sorted Arrays II
    上面已经回答了，如果有重复元素的只能O(N)
Search Insert Position
    可以用我之前的提到的二分方法，这样可以直接找到这个位置
Set Matrix Zeroes
    不用额外的空间做这个题，
    首先用2个bool变量，标记第0行是不是有0，第0列是不是有0
    然后把第0行作为每一列的标记数组，第0列作为每一行的标记数组，用来标记(i,j)若为0 则标记matrix[0][j] 和matrix[i][0] 这里只考虑(i >= 1 && j >= 1)
    最后根据matrix[0][j] matrix[i][0] 可以把相应的行列都赋值为0
    然后最后再看最开始的2个bool变量，把第0行 第0列赋值为0
Simplify Path
    字符串处理，中间用栈来保存每一级的目录名，如果碰到..就谈栈，否则就是把这个目录名压栈
    最后一个个弹栈，把路径拼接好
Sort Colors
    有3个下标，index0 index1 index2分别表示3个下标
    一开始index0 = index1 = 0, index2 = N - 1
    整个过程里index0 一定指向从左边开始第一个非0的元素，index2一定指向从右边开始第一个非2的元素
    index1从头开始扫描，扫到A[index1]==0那么就和A[index0]交换，然后index0++, index1++
    若A[index1] == 2 就和A[index2]交换，然后index2--
    若A[index1] == 1 那就直接index1++
    最后index1 == index2 就结束了排序
Spiral Matrix
    有一种递归的做法，我认为比较直观好写。
    一开始就是传入(0, 0, N - 1, M - 1) 表示处理最外面一层，
    然后4次循环可以把这一层的四条边处理掉，然后递归下去(x1 + 1, y1 + 1, x2 - 1, y2 - 1) 直到最后
Spiral Matrix II
    可以用上面的逆方法，填充整个N*N的矩阵
Sqrt(x)
    L = 1， R = x 二分求sqrt(x)
String to Integer (atoi)
    注意最前面的正负符号，处理到第一个非数字的符号
Subsets
    递归,类似求全排列，只是全排列是到最后才保存答案，这里是递归到下一层的同时，它自己也构成一个子集合
Subsets II
    有重复的元素，去除这些情况的方法同排列一样，就是递归去下一层的时候，记得check之前是否用过这个元素在这一层递归
Substring with Concatenation of All Words
    因为每个word的长度都一样，这是这题的tricky点，
    从0-(L-1)这些位置出发，每次步长都是L然后看是不是match某个word，如果不是就直接从下一个位置开始，否则就标记match这个word了，然后
Sudoku Solver
    递归求解。递归之前，先把已经填好的部分所在的行列小方块使用1-9的情况都标记好。
    然后开始递归，递归时，如果这个位置已经有数字，就直接去下一个，如果是空的，就枚举填写什么，然后check是不是满足每列每行所在小方块都是1-9。
Swap Nodes in Pairs
    这个可以理解成k=2的那个旋转k group吧，可以直接套用那个方法，不过也可以简单一点，每次把2个元素取出来，然后弄。
Symmetric Tree
    递归判断，同时传入2个参数(root,root) 然后判断的时候左子树和右子树判断，
    就是递归下去的时候调用(root->left, root->right) (root->right, root->left) 
    
Text Justification
    根据它的规则，每一行往后面连接字符串，直到会超过这行的宽度，然后计算填充的空格。
    最后一行的规则不太一样，需要注意。
Trapping Rain Water
    left[i] 表示i左边最大的高度，right[i]表示i右边最大的高度
    可以O(N)时间，分别求出left[i] right[i]
    left[i] = max(left[i - 1], height[i])
    right[i] = max(right[i + 1], height[i])
    最后再O(N)扫描，ans += min(right[i], left[i]) - heigh[i]
Triangle
    动态规划，F[i][j]表示从top走到i,j的最大和
    F[i][j] = min(F[i - 1][j], F[i - 1][j - 1]) + A[i][j]
    注意每行的元素比上一行多一个，需要特殊if一下
    ans = max(F[N][i]) 最后一行里最大的
Two Sum
    跟之前做3Sum的方法类似，只是这里最后需要下标，所以把元素带着下标排序，
    之后再一个Left从0到N，一个Right从N到0找到相应的解
Unique Binary Search Trees
    F[i]表示i个节点的二叉树的个数
    F[i] = sigma{ F[k] * F[i - 1 - k]   } k = 0 ~ i - 1
Unique Binary Search Trees II
    用上题的思路，递归求解，每一层，枚举k然后下去 左子树为k个节点的子树所有样子，然后求出右子树为i - 1 - k的所有样子，
    然后拼成这一层的所有解
Unique Paths
    F[i][j]表示走到(i,j)的方案数
    F[i][j] = F[i - 1][j] + F[i][j - 1]
Unique Paths II
    F[i][j]表示走到(i,j)的方案数
    如果 grid[i][j] == 1 那么 F[i][j] = 0 
    否则 F[i][j] = F[i - 1][j] + F[i][j - 1]
Valid Number
    这题需要考虑3种情况，是否integer，是否float，是否科学表示法
    是否integer，除了第一位可能是+- 其他都是数字，且必须有数字
    是否float，除了第一位可能是+- 之后只可以出现一次小数点，且必须有数字
    是否科学表示法，第一位可以是+- e后面必须有+-
Valid Palindrome
    left right两个指针从两头扫即可，只需要考虑digit 和 alpha，这样如果空串也当作回文的话，不用特殊处理
Valid Parentheses
    用栈来check，每次碰到左括号就压栈，然后碰到有括号就判断top是不是跟它一对，如果是就pop，不是就invalid
Valid Sudoku
    这题和之前Sudoku Solver类似，更简单，因为只要判断现在的局面是不是可行的。
Validate Binary Search Trees		
    判断其中序遍历是不是上升序列
Wildcard Matching
    F[i][j] 表示s的前i个字符可否match p的前j个字符
    F[i][j] = F[i - 1][j] && p[j] == '*'  *可以匹配大于等于2个字符
	  || F[i][j - 1] && p[j] == '*' *可以匹配0个字符
	  || F[i - 1][j - 1] && (s[i] == p[j] || p[j] == '?' || p[j] == '*')
Word Search
    递归检查，
    首先枚举从哪个位置开始match，
    然后开始递归，每一层可以枚举向4个方向扩展，并且不要标记这个位置已经走过，
    然后每往下走的满足条件就是 这个字符要相应的match，并且这个位置之前没有走到过
ZigZag Conversion
    直接开一个K大小的数组，模拟就好
